var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { useState, useEffect, useLayoutEffect, useCallback } from 'react';
import { ErrorType, styled } from '@workday/canvas-kit-react-common';
import { Popper, useCloseOnEscape } from '@workday/canvas-kit-react-popup';
import { colors, borderRadius, inputColors } from '@workday/canvas-kit-react-core';
import { buttonBorderWidth } from './SelectBase';
export var menuAnimationDuration = 200;
var menuBorderStyles = function (theme, error) {
    var borderColor = theme.canvas.palette.common.focusOutline;
    var dividerBorderColor = borderColor;
    var dividerBorderWidth = 1;
    if (error === ErrorType.Error) {
        borderColor = theme.canvas.palette.error.main;
        dividerBorderColor = borderColor;
    }
    else if (error === ErrorType.Alert) {
        borderColor = theme.canvas.palette.alert.darkest;
        dividerBorderColor = theme.canvas.palette.alert.main;
        dividerBorderWidth = 2;
    }
    var dividerBorder = dividerBorderWidth + "px solid " + dividerBorderColor;
    return {
        borderColor: borderColor,
        '&:before': {
            backgroundColor: colors.soap400,
            borderLeft: dividerBorder,
            borderRight: dividerBorder,
            boxSizing: 'border-box',
            content: '""',
            display: 'block',
            height: 1,
            position: 'absolute',
            width: '100%',
            '[data-popper-placement="bottom"] &': {
                top: 0,
            },
            '[data-popper-placement="top"] &': {
                bottom: 0,
            },
        },
    };
};
var menuListBorderStyles = function (theme, error) {
    var borderColor = theme.canvas.palette.common.focusOutline;
    var borderWidth = 1;
    if (error === ErrorType.Error) {
        borderColor = theme.canvas.palette.error.main;
    }
    else if (error === ErrorType.Alert) {
        borderColor = theme.canvas.palette.alert.main;
        borderWidth = 2;
    }
    var border = borderWidth + "px solid " + borderColor;
    return {
        borderLeft: border,
        borderRight: border,
        '[data-popper-placement="bottom"] &': {
            borderBottom: border,
        },
        '[data-popper-placement="top"] &': {
            borderTop: border,
        },
    };
};
var Menu = styled('div')({
    backgroundColor: colors.frenchVanilla100,
    border: "1px solid " + inputColors.border,
    boxSizing: 'border-box',
    position: 'relative',
    transition: "opacity " + menuAnimationDuration + "ms",
    '[data-popper-placement="bottom"] &': {
        borderRadius: "0 0 " + borderRadius.m + " " + borderRadius.m,
        borderTop: 0,
    },
    '[data-popper-placement="top"] &': {
        borderRadius: borderRadius.m + " " + borderRadius.m + " 0 0",
        borderBottom: 0,
    },
}, function (_a) {
    var error = _a.error, theme = _a.theme;
    return (__assign({}, menuBorderStyles(theme, error)));
}, function (_a) {
    var visibility = _a.visibility;
    return ({
        opacity: visibility === 'opening' || visibility === 'opened' || visibility === 'close' ? 1 : 0,
    });
}, function (_a) {
    var width = _a.width;
    return ({
        width: width,
    });
});
var MenuList = styled('ul')({
    listStyle: 'none',
    margin: 0,
    maxHeight: 200,
    outline: 'none',
    overflowY: 'auto',
    padding: 0,
}, function (_a) {
    var error = _a.error, theme = _a.theme;
    return (__assign({}, menuListBorderStyles(theme, error)));
});
var generatePopperOptions = function (props) {
    var menuRef = props.menuRef, placement = props.placement, shouldAutoFlip = props.shouldAutoFlip, shouldAutoFocus = props.shouldAutoFocus;
    var fallbackPlacements = [];
    if (shouldAutoFlip) {
        fallbackPlacements = placement === 'top' ? ['bottom'] : ['top'];
    }
    var modifiers = [
        {
            name: 'flip',
            options: {
                fallbackPlacements: fallbackPlacements,
            },
        },
        {
            name: 'offset',
            options: {
                offset: function () {
                    var skidding = 0;
                    var distance = -parseInt(borderRadius.m, 10);
                    return [skidding, distance];
                },
            },
        },
        {
            name: 'preventOverflow',
            options: {
                mainAxis: false,
            },
        },
    ];
    return {
        modifiers: modifiers,
        onFirstUpdate: function () {
            if (shouldAutoFocus && menuRef && menuRef.current) {
                menuRef.current.focus();
            }
        },
    };
};
var SelectMenu = function (_a) {
    var buttonRef = _a.buttonRef, children = _a.children, error = _a.error, menuRef = _a.menuRef, onCloseOnEscape = _a.onCloseOnEscape, _b = _a.placement, placement = _b === void 0 ? 'bottom' : _b, _c = _a.shouldAutoFlip, shouldAutoFlip = _c === void 0 ? true : _c, _d = _a.shouldAutoFocus, shouldAutoFocus = _d === void 0 ? true : _d, _e = _a.visibility, visibility = _e === void 0 ? 'closed' : _e, elemProps = __rest(_a, ["buttonRef", "children", "error", "menuRef", "onCloseOnEscape", "placement", "shouldAutoFlip", "shouldAutoFocus", "visibility"]);
    var popupRef = React.useRef(null);
    var _f = useState(0), width = _f[0], setWidth = _f[1];
    var handleWidthChange = useCallback(function () {
        if (buttonRef.current && visibility !== 'closed') {
            var newMenuWidth = buttonRef.current.clientWidth + 2 * buttonBorderWidth;
            setWidth(newMenuWidth);
        }
    }, [buttonRef, visibility]);
    useLayoutEffect(function () {
        handleWidthChange();
    }, [handleWidthChange]);
    useEffect(function () {
        window.addEventListener('resize', handleWidthChange);
        return function () {
            window.removeEventListener('resize', handleWidthChange);
        };
    }, [handleWidthChange]);
    useCloseOnEscape(popupRef, function () { return onCloseOnEscape === null || onCloseOnEscape === void 0 ? void 0 : onCloseOnEscape(); });
    return (React.createElement(Popper, { placement: placement, anchorElement: buttonRef, popperOptions: generatePopperOptions({
            menuRef: menuRef,
            placement: placement,
            shouldAutoFlip: shouldAutoFlip,
            shouldAutoFocus: shouldAutoFocus,
        }), ref: popupRef },
        React.createElement(Menu, { error: error, visibility: visibility, width: width },
            React.createElement(MenuList, __assign({ error: error, ref: menuRef, role: "listbox", tabIndex: -1 }, elemProps), children))));
};
export default SelectMenu;
