var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _a;
import * as React from 'react';
import elementClosestPolyfill from 'element-closest';
export var InputType;
(function (InputType) {
    InputType["Initial"] = "initial";
    InputType["Keyboard"] = "keyboard";
    InputType["Mouse"] = "mouse";
    InputType["Pointer"] = "pointer";
    InputType["Touch"] = "touch";
})(InputType || (InputType = {}));
export var InputEventType;
(function (InputEventType) {
    InputEventType["KeyDown"] = "keydown";
    InputEventType["KeyUp"] = "keyup";
    InputEventType["MouseDown"] = "mousedown";
    InputEventType["MouseMove"] = "mousemove";
    InputEventType["Wheel"] = "wheel";
    InputEventType["MouseWheel"] = "mousewheel";
    InputEventType["PointerDown"] = "pointerdown";
    InputEventType["PointerMove"] = "pointermove";
    InputEventType["TouchStart"] = "touchstart";
})(InputEventType || (InputEventType = {}));
var formInputs = ['input', 'select', 'textarea'];
var ignoreMap = [
    16,
    17,
    18,
    91,
    93,
];
export var inputEventMap = (_a = {},
    _a[InputEventType.KeyDown] = InputType.Keyboard,
    _a[InputEventType.KeyUp] = InputType.Keyboard,
    _a[InputEventType.MouseDown] = InputType.Mouse,
    _a[InputEventType.MouseMove] = InputType.Mouse,
    _a[InputEventType.Wheel] = InputType.Mouse,
    _a[InputEventType.MouseWheel] = InputType.Mouse,
    _a[InputEventType.PointerDown] = InputType.Pointer,
    _a[InputEventType.PointerMove] = InputType.Pointer,
    _a[InputEventType.TouchStart] = InputType.Touch,
    _a);
var pointerMap = {
    2: InputType.Touch,
    3: InputType.Touch,
    4: InputType.Mouse,
};
var getPointerType = function (event) {
    if (typeof event.pointerType === 'number') {
        return pointerMap[event.pointerType];
    }
    else if (event.pointerType === 'mouse') {
        return InputType.Mouse;
    }
    else {
        return InputType.Touch;
    }
};
var detectWheel = function () {
    var wheelType;
    if ('onwheel' in document.createElement('div')) {
        wheelType = InputEventType.Wheel;
    }
    else {
        wheelType = InputEventType.MouseWheel;
    }
    return wheelType;
};
var supportsPassive = function () {
    var supportsPassive;
    try {
        var opts = Object.defineProperty({}, 'passive', {
            get: function () {
                supportsPassive = true;
            },
        });
        var stub = function () {
            return;
        };
        window.addEventListener('test', stub, opts);
        window.removeEventListener('test', stub, opts);
    }
    catch (e) {
        console.warn('Browser does not support passive event listeners');
    }
    return supportsPassive || false;
};
var InputProvider = (function (_super) {
    __extends(InputProvider, _super);
    function InputProvider(props) {
        var _this = _super.call(this, props) || this;
        _this.isBuffering = false;
        _this.isScrolling = false;
        _this.mousePosX = null;
        _this.mousePosY = null;
        _this.deferInputTracking = false;
        _this.provideIntent = _this.props.provideIntent;
        var storedInput, storedIntent;
        try {
            storedInput = window.sessionStorage.getItem('what-input');
            storedIntent = window.sessionStorage.getItem('what-intent');
        }
        catch (e) {
            console.warn('Failed to retrieve input status from session storage' + e);
        }
        _this.currentInput = storedInput || InputType.Initial;
        _this.currentIntent = storedIntent || InputType.Initial;
        _this.setInput = _this.setInput.bind(_this);
        _this.setIntent = _this.setIntent.bind(_this);
        _this.eventBuffer = _this.eventBuffer.bind(_this);
        return _this;
    }
    InputProvider.prototype.getContainer = function (container) {
        if (!container) {
            return document.body;
        }
        if ('current' in container) {
            if (container.current === null) {
                console.warn('Your ref object can not be null, therefore, falling back to document.body');
                return document.body;
            }
            else {
                return container.current;
            }
        }
        return container;
    };
    InputProvider.prototype.componentDidMount = function () {
        elementClosestPolyfill(window);
        this.supportsPassive = supportsPassive();
        if (this.getContainer(this.props.container).closest('[data-whatinput]')) {
            this.deferInputTracking = true;
            return;
        }
        this.updateAttributes();
        this.enableListeners(true);
    };
    InputProvider.prototype.updateAttributes = function () {
        var intent = this.provideIntent ? this.currentIntent : null;
        this.getContainer(this.props.container).setAttribute('data-whatinput', this.currentInput);
        if (intent) {
            this.getContainer(this.props.container).setAttribute('data-whatintent', intent);
        }
        try {
            window.sessionStorage.setItem('what-input', this.currentInput);
            window.sessionStorage.setItem('what-intent', this.currentIntent);
        }
        catch (e) {
            console.warn('Failed to set input status in session storage' + e);
        }
    };
    InputProvider.prototype.componentWillUnmount = function () {
        if (this.deferInputTracking) {
            return;
        }
        this.getContainer(this.props.container).removeAttribute('data-whatinput');
        this.getContainer(this.props.container).removeAttribute('data-whatintent');
        window.clearTimeout(this.eventTimer);
        this.enableListeners(false);
    };
    InputProvider.prototype.enableListeners = function (enable) {
        if (typeof window === 'undefined') {
            return;
        }
        var options = this.supportsPassive
            ? { passive: true }
            : false;
        var fn = enable ? window.addEventListener : window.removeEventListener;
        if (window.PointerEvent) {
            fn('pointerdown', this.setInput);
        }
        else {
            fn('mousedown', this.setInput);
            if ('ontouchstart' in window) {
                fn('touchstart', this.eventBuffer, options);
                fn('touchend', this.setInput);
            }
        }
        if (this.provideIntent) {
            if (window.PointerEvent) {
                fn('pointermove', this.setIntent);
            }
            else {
                fn('mousemove', this.setIntent);
            }
            fn(detectWheel(), this.setIntent, options);
        }
        fn('keydown', this.eventBuffer);
        fn('keyup', this.eventBuffer);
    };
    InputProvider.prototype.setInput = function (event) {
        if (this.isBuffering) {
            return;
        }
        var eventKey = 'which' in event ? event.which : undefined;
        var eventType = event.type;
        var value = inputEventMap[eventType];
        if (value === InputType.Pointer) {
            value = getPointerType(event);
        }
        var ignoreMatch = eventKey ? ignoreMap.indexOf(eventKey) === -1 : undefined;
        var shouldUpdate = (value === InputType.Keyboard && eventKey && ignoreMatch) ||
            value === InputType.Mouse ||
            value === InputType.Touch;
        if (this.currentInput !== value && shouldUpdate) {
            this.currentInput = value;
            this.updateAttributes();
        }
        if (this.currentIntent !== value && shouldUpdate && this.provideIntent) {
            var activeElem = document.activeElement;
            var notFormInput = activeElem &&
                activeElem.nodeName &&
                formInputs.indexOf(activeElem.nodeName.toLowerCase()) === -1;
            if (notFormInput) {
                this.currentIntent = value;
                this.updateAttributes();
            }
        }
    };
    InputProvider.prototype.setIntent = function (event) {
        this.detectScrolling(event);
        if (!this.isBuffering && !this.isScrolling) {
            var eventType = event.type;
            var value = inputEventMap[eventType];
            if (value === InputType.Pointer) {
                value = getPointerType(event);
            }
            this.currentIntent = value;
            this.updateAttributes();
        }
    };
    InputProvider.prototype.eventBuffer = function (event) {
        var _this = this;
        this.setInput(event);
        window.clearTimeout(this.eventTimer);
        this.isBuffering = true;
        this.eventTimer = window.setTimeout(function () {
            _this.isBuffering = false;
        }, 100);
    };
    InputProvider.prototype.detectScrolling = function (event) {
        if (this.mousePosX !== event.screenX || this.mousePosY !== event.screenY) {
            this.isScrolling = false;
            this.mousePosX = event.screenX;
            this.mousePosY = event.screenY;
        }
        else {
            this.isScrolling = true;
        }
    };
    InputProvider.prototype.render = function () {
        return this.props.children || null;
    };
    return InputProvider;
}(React.Component));
export default InputProvider;
