{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as React from 'react';\nimport { ErrorType } from '@workday/canvas-kit-react-common';\nimport { menuAnimationDuration } from './SelectMenu';\nimport SelectBase from './SelectBase';\nimport { getCorrectedIndexByValue } from './utils';\nimport uuid from 'uuid/v4';\n\nvar Select = function (_super) {\n  __extends(Select, _super);\n\n  function Select(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      focusedOptionIndex: 0,\n      menuVisibility: 'closed'\n    };\n    _this.buttonRef = React.createRef();\n    _this.inputRef = React.createRef();\n    _this.menuRef = React.createRef();\n    _this.keysSoFar = '';\n    _this.clearKeysSoFarTimeout = 500;\n    _this.normalizedOptions = [];\n\n    _this.areOptionsDefined = function () {\n      var options = _this.props.options;\n\n      if (!options || options.length === 0) {\n        return false;\n      }\n\n      return true;\n    };\n\n    _this.setNormalizedOptions = function () {\n      var options = _this.props.options;\n\n      if (!_this.areOptionsDefined()) {\n        return;\n      }\n\n      _this.normalizedOptions = options.map(function (option) {\n        var data = {};\n        var disabled, id, label, value;\n\n        if (typeof option === 'string') {\n          disabled = false;\n          id = uuid();\n          value = option;\n          label = option;\n        } else {\n          data = option.data || data;\n          disabled = !!option.disabled;\n          id = option.id || uuid();\n          value = option.value;\n          label = option.label || option.value;\n        }\n\n        return {\n          data: data,\n          disabled: disabled,\n          id: id,\n          label: label,\n          value: value\n        };\n      });\n    };\n\n    _this.getIndexByStartString = function (startIndex, startString, endIndex, ignoreDisabled) {\n      if (endIndex === void 0) {\n        endIndex = _this.normalizedOptions.length;\n      }\n\n      if (ignoreDisabled === void 0) {\n        ignoreDisabled = true;\n      }\n\n      for (var i = startIndex; i < endIndex; i++) {\n        var label = _this.normalizedOptions[i].label.toLowerCase();\n\n        if (label.indexOf(startString.toLowerCase()) === 0) {\n          if (!ignoreDisabled || ignoreDisabled && !_this.normalizedOptions[i].disabled) {\n            return i;\n          }\n        }\n      }\n\n      return -1;\n    };\n\n    _this.focusNextEnabledOption = function (startIndex, direction) {\n      if (direction === 0) {\n        return;\n      }\n\n      var numOptions = _this.normalizedOptions.length;\n      var currentIndex = startIndex;\n\n      while (currentIndex >= 0 && currentIndex < numOptions && _this.normalizedOptions[currentIndex].disabled) {\n        currentIndex += direction;\n      }\n\n      if (currentIndex >= 0 && currentIndex < numOptions && !_this.normalizedOptions[currentIndex].disabled) {\n        _this.setState({\n          focusedOptionIndex: currentIndex\n        });\n      }\n    };\n\n    _this.updateStateFromValue = function () {\n      _this.setState({\n        focusedOptionIndex: getCorrectedIndexByValue(_this.normalizedOptions, _this.props.value)\n      });\n    };\n\n    _this.focusButton = function () {\n      if (_this.buttonRef.current) {\n        _this.buttonRef.current.focus();\n      }\n    };\n\n    _this.setMenuAnimationTimeout = function (callback) {\n      if (_this.menuAnimationTimer) {\n        clearTimeout(_this.menuAnimationTimer);\n      }\n\n      _this.menuAnimationTimer = setTimeout(callback, menuAnimationDuration);\n    };\n\n    _this.openMenu = function () {\n      _this.setState({\n        menuVisibility: 'opening'\n      });\n\n      _this.setMenuAnimationTimeout(function () {\n        _this.setState({\n          menuVisibility: 'opened'\n        });\n      });\n    };\n\n    _this.closeMenu = function () {\n      _this.setState({\n        menuVisibility: 'closing'\n      });\n\n      _this.setMenuAnimationTimeout(function () {\n        _this.setState({\n          focusedOptionIndex: getCorrectedIndexByValue(_this.normalizedOptions, _this.props.value),\n          menuVisibility: 'closed'\n        });\n      });\n    };\n\n    _this.toggleMenu = function (open) {\n      var menuVisibility = _this.state.menuVisibility;\n\n      if (open) {\n        switch (menuVisibility) {\n          case 'closed':\n            _this.setState({\n              menuVisibility: 'open'\n            }, _this.openMenu);\n\n            break;\n\n          case 'close':\n          case 'closing':\n            _this.openMenu();\n\n            break;\n\n          default:\n            break;\n        }\n      } else {\n        switch (menuVisibility) {\n          case 'opened':\n            _this.setState({\n              menuVisibility: 'close'\n            }, _this.closeMenu);\n\n            break;\n\n          case 'open':\n          case 'opening':\n            _this.closeMenu();\n\n            break;\n\n          default:\n            break;\n        }\n      }\n    };\n\n    _this.fireChangeEvent = function (value) {\n      if (_this.inputRef && _this.inputRef.current) {\n        var nativeInputValue = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(_this.inputRef.current), 'value');\n\n        if (nativeInputValue && nativeInputValue.set) {\n          nativeInputValue.set.call(_this.inputRef.current, value);\n        }\n\n        var event_1;\n\n        if (typeof Event === 'function') {\n          event_1 = new Event('change', {\n            bubbles: true\n          });\n        } else {\n          event_1 = document.createEvent('Event');\n          event_1.initEvent('change', true, true);\n        }\n\n        _this.inputRef.current.dispatchEvent(event_1);\n      }\n    };\n\n    _this.handleKeyboardTypeAhead = function (key, numOptions) {\n      if (_this.state.menuVisibility === 'closing') {\n        return;\n      }\n\n      var start = _this.keysSoFar.length === 0 ? _this.state.focusedOptionIndex + 1 : _this.state.focusedOptionIndex;\n      start = start === numOptions ? 0 : start;\n      _this.keysSoFar += key;\n\n      _this.startClearKeysSoFarTimer();\n\n      var matchIndex;\n      matchIndex = _this.getIndexByStartString(start, _this.keysSoFar);\n\n      if (matchIndex === -1) {\n        matchIndex = _this.getIndexByStartString(0, _this.keysSoFar, start);\n      }\n\n      if (matchIndex > -1) {\n        if (_this.state.menuVisibility === 'closed') {\n          _this.fireChangeEvent(_this.normalizedOptions[matchIndex].value);\n        } else {\n          _this.setState({\n            focusedOptionIndex: matchIndex\n          });\n        }\n      }\n    };\n\n    _this.startClearKeysSoFarTimer = function () {\n      if (_this.clearKeysSoFarTimer) {\n        clearTimeout(_this.clearKeysSoFarTimer);\n      }\n\n      _this.clearKeysSoFarTimer = setTimeout(function () {\n        _this.keysSoFar = '';\n      }, _this.clearKeysSoFarTimeout);\n    };\n\n    _this.handleMouseDown = function (event) {\n      event.preventDefault();\n    };\n\n    _this.handleClick = function (event) {\n      var menuVisibility = _this.state.menuVisibility;\n\n      switch (menuVisibility) {\n        case 'close':\n        case 'closing':\n          if (_this.menuRef.current) {\n            _this.menuRef.current.focus();\n          }\n\n          _this.toggleMenu(true);\n\n          break;\n\n        case 'closed':\n          _this.toggleMenu(true);\n\n          break;\n\n        default:\n          _this.focusButton();\n\n          _this.toggleMenu(false);\n\n          break;\n      }\n    };\n\n    _this.handleOptionSelection = function (index) {\n      if (_this.normalizedOptions[index].disabled) {\n        return;\n      }\n\n      _this.toggleMenu(false);\n\n      _this.focusButton();\n\n      _this.fireChangeEvent(_this.normalizedOptions[index].value);\n    };\n\n    _this.handleMenuBlur = function (event) {\n      _this.toggleMenu(false);\n    };\n\n    _this.handleMenuCloseOnKeyPress = function () {\n      _this.toggleMenu(false);\n\n      _this.focusButton();\n    };\n\n    _this.handleKeyDown = function (event) {\n      var options = _this.props.options;\n      var numOptions = options.length;\n      var _a = _this.state,\n          focusedOptionIndex = _a.focusedOptionIndex,\n          menuVisibility = _a.menuVisibility;\n      var isShortcut = false;\n\n      if (event.key.length === 1 && event.key.match(/\\S/)) {\n        isShortcut = true;\n\n        _this.handleKeyboardTypeAhead(event.key, numOptions);\n      } else {\n        switch (event.key) {\n          case 'ArrowUp':\n          case 'Up':\n          case 'ArrowDown':\n          case 'Down':\n            isShortcut = true;\n\n            if (menuVisibility === 'closed' || menuVisibility === 'closing') {\n              _this.toggleMenu(true);\n            } else {\n              var direction_1 = event.key === 'ArrowUp' || event.key === 'Up' ? -1 : 1;\n              var startIndex_1 = focusedOptionIndex + direction_1;\n\n              _this.focusNextEnabledOption(startIndex_1, direction_1);\n            }\n\n            break;\n\n          case 'Home':\n          case 'End':\n            isShortcut = true;\n            var direction = event.key === 'Home' ? 1 : -1;\n            var startIndex = event.key === 'Home' ? 0 : numOptions - 1;\n\n            _this.focusNextEnabledOption(startIndex, direction);\n\n            break;\n\n          case 'Tab':\n            if (menuVisibility !== 'closed') {\n              isShortcut = true;\n\n              _this.handleMenuCloseOnKeyPress();\n            }\n\n            break;\n\n          case 'Spacebar':\n          case ' ':\n            isShortcut = true;\n\n            if (_this.keysSoFar !== '') {\n              _this.handleKeyboardTypeAhead(' ', numOptions);\n            } else if (menuVisibility === 'closed' || menuVisibility === 'closing') {\n              _this.toggleMenu(true);\n            } else {\n              _this.handleOptionSelection(focusedOptionIndex);\n            }\n\n            break;\n\n          case 'Enter':\n            isShortcut = true;\n\n            if (menuVisibility === 'closed' || menuVisibility === 'closing') {\n              _this.toggleMenu(true);\n            } else {\n              _this.handleOptionSelection(focusedOptionIndex);\n            }\n\n            break;\n\n          default:\n        }\n      }\n\n      if (isShortcut) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    };\n\n    _this.setNormalizedOptions();\n\n    return _this;\n  }\n\n  Select.prototype.componentDidMount = function () {\n    this.updateStateFromValue();\n  };\n\n  Select.prototype.componentDidUpdate = function (prevProps) {\n    var _a = this.props,\n        options = _a.options,\n        value = _a.value;\n\n    if (options !== prevProps.options) {\n      this.setNormalizedOptions();\n      this.updateStateFromValue();\n    }\n\n    if (value !== prevProps.value) {\n      this.updateStateFromValue();\n    }\n  };\n\n  Select.prototype.componentWillUnmount = function () {\n    if (this.menuAnimationTimer) {\n      clearTimeout(this.menuAnimationTimer);\n    }\n\n    if (this.clearKeysSoFarTimer) {\n      clearTimeout(this.clearKeysSoFarTimer);\n    }\n  };\n\n  Select.prototype.render = function () {\n    var _a = this.props,\n        value = _a.value,\n        options = _a.options,\n        elemProps = __rest(_a, [\"value\", \"options\"]);\n\n    var _b = this.state,\n        focusedOptionIndex = _b.focusedOptionIndex,\n        menuVisibility = _b.menuVisibility;\n    var eventHandlers = this.areOptionsDefined() ? {\n      onClick: this.handleClick,\n      onKeyDown: this.handleKeyDown,\n      onMenuBlur: this.handleMenuBlur,\n      onMenuCloseOnEscape: this.handleMenuCloseOnKeyPress,\n      onMouseDown: this.handleMouseDown,\n      onOptionSelection: this.handleOptionSelection\n    } : {};\n    return React.createElement(SelectBase, __assign({\n      buttonRef: this.buttonRef,\n      focusedOptionIndex: focusedOptionIndex,\n      inputRef: this.inputRef,\n      menuRef: this.menuRef,\n      menuVisibility: menuVisibility,\n      options: this.normalizedOptions,\n      value: value\n    }, eventHandlers, elemProps));\n  };\n\n  Select.ErrorType = ErrorType;\n  return Select;\n}(React.Component);\n\nSelect.ErrorType = ErrorType;\nexport default Select;","map":null,"metadata":{},"sourceType":"module"}